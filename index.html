<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='http://fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.3"/>


    <meta name="description" content="“大多数人按照我们所安排的路线生活，害怕探索其它路线，但也会有一些人，他们并不满足于被设定的生活轨迹，冲破我们设置的重重阻碍，意识到自由意志是天赐之物的人，才明白只有在奋力抗争后才知道如何善用之。”" />



  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.3" />



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    analytics: {
      google: ''
    },
    sidebar: 'post'
  };
</script>




  <title> LOCATINO'S NOTES </title>
</head>

<body>
  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->

  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">LOCATINO'S NOTES</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<div class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            <i class="menu-item-icon icon-about"></i> <br />
            關於
          </a>
        </li>
      
    </ul>
  

  
</div>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <div id="posts" class="posts-expand">
    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/21/stack-over-flow-1/">
                Stack Overflow经典问题选讲(1)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-09-21
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/MEMO/">MEMO</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <h2 id="Question">Question</h2><p>下面是一段非常神奇的<strong>C++</strong>代码。因为一些莫名其妙的原因，处理排序后的数据比没有排序的数据奇迹般的快了许多倍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;algorithm&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;ctime&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;iostream&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// Generate data</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> arraySize = <span class="number">32768</span>;</span><br><span class="line">    <span class="keyword">int</span> data[arraySize];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">        data[c] = <span class="built_in">std</span>::rand() % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// !!! With this, the next loop runs faster</span></span><br><span class="line">    <span class="built_in">std</span>::sort(data, data + arraySize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test</span></span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Primary loop</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">                sum += data[c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> elapsedTime = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(clock() - start) / CLOCKS_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; elapsedTime &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum = "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>没有<code>std::sort(data, data + arraySize);</code>这句代码，程序运行了<strong>11.54</strong>秒。</li>
<li>有上述那句代码，程序运行了<strong>1.93</strong>秒。</li>
</ul>
<p>最开始，我以为这只是特定语言或者编译器的反常现象。所以我在<strong>Java</strong>里也试了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">// Generate data</span></span><br><span class="line">        <span class="keyword">int</span> arraySize = <span class="number">32768</span>;</span><br><span class="line">        <span class="keyword">int</span> data[] = <span class="keyword">new</span> <span class="keyword">int</span>[arraySize];</span><br><span class="line"></span><br><span class="line">        Random rnd = <span class="keyword">new</span> Random(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">            data[c] = rnd.nextInt() % <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !!! With this, the next loop runs faster</span></span><br><span class="line">        Arrays.sort(data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Test</span></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Primary loop</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; arraySize; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">                    sum += data[c];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println((System.nanoTime() - start) / <span class="number">1000000000.0</span>);</span><br><span class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果也类似，只不过速度差异没有那么夸张。<br>我最初以为是因为排序把数据带入了高速缓存里，但马上就发现这个想法多么愚蠢，因为数组是运行时生成的。</p>
<ul>
<li>发生了什么事？</li>
<li>为什么排序后的数组比没有排序的数组处理起来快？</li>
<li>代码仅仅把数据元素单独的相加，数据元的顺序应该没有影响才对。</li>
</ul>
<hr>
<p><br></p>
<h2 id="Answer">Answer</h2><p>你是<a href="https://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="external">分支预测</a>(branch prediction)失败的受害者。</p>
<hr>
<h2 id="什么是分支预测？">什么是分支预测？</h2><p>请参考下图铁轨分岔路：<br><img src="http://i.stack.imgur.com/muxnt.jpg" alt="train_pic"><br>为了方便说明这个程序问题，假设我们回到了1800年代——在无线电或者其他长距离通信方式发明之前。<br>你是一名操作员，你听到了一辆火车正在驶来。你不知道它要走哪个方向。你停下了火车去问列车长他要走哪个方向。然后你正确地设置了分岔口的开关。<br><br><br><em>火车重，并且惯性大。所以它们启动和停下需要花费大量的时间。</em><br><br><br>那有没有更好的方式？你来猜火车会走哪条路！</p>
<ul>
<li>如果你猜对了，火车就继续走。</li>
<li>如果你猜错了，那列车长会停车，退回，训斥你重新操作分岔开关。然后火车重新驶向另一条路。</li>
</ul>
<p><strong>如果你每次都猜对，</strong>火车将永远不用停下来。</p>
<p><strong>如果你老是猜错，</strong>火车将会花费大量的时间停下来，退回，重启。</p>
<hr>
<p><strong>观察下列if语句：</strong>在处理器层面上，它是一条分支指令：<br><img src="http://i.stack.imgur.com/pyfwC.png" alt="branch_instruction"><br>假设你是一个处理器并且你发现了一个分支指令。你不知道接下来会执行哪条指令。你怎么办？你挂起了程序，等待之前的指令执行完毕。然后你顺着正确的分支继续执行。<br><br><br><em>现代处理器结构复杂并且拥有长流水线。所以它们启动和停止需要花费大量的时间。</em><br><br><br>那有没有更好的方式？你来猜接下来会执行哪条分支！</p>
<ul>
<li>如果你猜对了，你就继续执行。</li>
<li>如果你猜错了，你需要刷新指令流水线并回退到分支语句。然后你重新执行正确地分支。</li>
</ul>
<p><strong>如果你每次都猜对，</strong>执行将永远不用停止。<br><strong>如果你老是猜错，</strong>你将花费大量的时间停止，回退，重启。</p>
<hr>
<p>这就是分支预测。我承认上面的比喻不是最合适的，因为火车只需要打一面标识行进方向的旗子就可以了。但是计算机里，处理器不到最后一刻是不会知道该进入哪条分支的。<br>所以你该如何选择猜测方案来最小化火车回退重启的次数呢？你观察之前的历史！如果火车99%的情况下走左边，那么你就猜左。反之，你就猜右。如果它每三次就走其中某个特定的方向，你就猜它接下来也是这样……<br><strong>换句话说，你试图找出一个模式并遵循它。</strong>这差不多就是分支预测器的工作方式。<br>大部分应用都有可良好预测的分支。所以现代分支预测器差不多可以达到&gt;90%的命中率。但是当面临无可预测的分支并且毫无规律可循的情况下，分支预测器基本上形同虚设。</p>
<p>深入阅读：<a href="http://en.wikipedia.org/wiki/Branch_predictor" target="_blank" rel="external">“Branch predictor” article on Wikipedia</a>。</p>
<hr>
<h2 id="根据以上所说，罪魁祸首就是这条if语句">根据以上所说，罪魁祸首就是这条if语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">	sum += data[c];</span><br></pre></td></tr></table></figure>
<p>注意到数据是均匀的分布在0到255之间。所以当数据从小到大排序之后，差不多前部分有一半的数据没有进入if语句的分支里。之后，剩下的数据全部进入if语句的分支里。<br>这对分支预测器是十分友好的，因为程序会连续的进入同一分支多次。一个简单的饱和计数器都可以正确的预测分支，除了刚好程序转向时的那几次失败。</p>
<h3 id="简单视图化">简单视图化</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">T</span> = branch taken</span><br><span class="line">N = branch not taken</span><br><span class="line"></span><br><span class="line">data[] = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="keyword">...</span> <span class="number">126</span>, <span class="number">127</span>, <span class="number">128</span>, <span class="number">129</span>, <span class="number">130</span>, <span class="keyword">...</span> <span class="number">250</span>, <span class="number">251</span>, <span class="number">252</span>, <span class="keyword">...</span></span><br><span class="line">branch = N  N  N  N  N  <span class="keyword">...</span>   N    N    <span class="literal">T</span>    <span class="literal">T</span>    <span class="literal">T</span>  <span class="keyword">...</span>   <span class="literal">T</span>    <span class="literal">T</span>    <span class="literal">T</span>  <span class="keyword">...</span></span><br><span class="line"></span><br><span class="line">       = NNNNNNNNNNNN <span class="keyword">...</span> NNNNNNNTTTTTTTTT <span class="keyword">...</span> TTTTTTTTTT  (easy to predict)</span><br></pre></td></tr></table></figure>
<p>然而，当数据完全随机，分支预测器毫无用处因为它无法预测随机数据。因此，大概有50%的错误预测。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data[] = <span class="number">226</span>, <span class="number">185</span>, <span class="number">125</span>, <span class="number">158</span>, <span class="number">198</span>, <span class="number">144</span>, <span class="number">217</span>, <span class="number">79</span>, <span class="number">202</span>, <span class="number">118</span>,  <span class="number">14</span>, <span class="number">150</span>, <span class="number">177</span>, <span class="number">182</span>, <span class="number">133</span>, <span class="keyword">...</span></span><br><span class="line">branch =   <span class="literal">T</span>,   <span class="literal">T</span>,   N,   <span class="literal">T</span>,   <span class="literal">T</span>,   <span class="literal">T</span>,   <span class="literal">T</span>,  N,   <span class="literal">T</span>,   N,   N,   <span class="literal">T</span>,   <span class="literal">T</span>,   <span class="literal">T</span>,   N  <span class="keyword">...</span></span><br><span class="line"></span><br><span class="line">       = TTNTTTTNTNNTTTN <span class="keyword">...</span>   (completely random - hard to predict)</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="所以应该如何是好？">所以应该如何是好？</h3><p>如果编译器没法把分支优化成可良好预测，你可以用一些技巧优化，如果你愿意为性能牺牲可读性的话。<br>将：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data[c] &gt;= <span class="number">128</span>)</span><br><span class="line">    sum += data[c];</span><br></pre></td></tr></table></figure></p>
<p>替换为：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t = (data[c] - <span class="number">128</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">sum += ~t &amp; data[c];</span><br></pre></td></tr></table></figure></p>
<p>这样就用一些位操作消除了分支。（上述方法并不等价于原来的if语句。仅仅是在这个例子中跟原来的if语句效果一样。）</p>
<h3 id="测试环境：Core_i7_920_@_3-5_GHz">测试环境：Core i7 920 @ 3.5 GHz</h3><p><code>C++ - Visual Studio 2010 - x64 Release</code><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  Branch - Random</span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">11.777</span></span><br><span class="line"><span class="comment"></span><br><span class="line">//  Branch - Sorted</span></span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">2.352</span></span><br><span class="line"><span class="comment"></span><br><span class="line">//  Branchless - Random</span></span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">2.564</span></span><br><span class="line"><span class="comment"></span><br><span class="line">//  Branchless - Sorted</span></span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">2.587</span></span><br></pre></td></tr></table></figure></p>
<p><code>Java - Netbeans 7.1.1 JDK 7 - x64</code><br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  Branch - Random</span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">10.93293813</span></span><br><span class="line"><span class="comment"></span><br><span class="line">//  Branch - Sorted</span></span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">5.643797077</span></span><br><span class="line"><span class="comment"></span><br><span class="line">//  Branchless - Random</span></span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">3.113581453</span></span><br><span class="line"><span class="comment"></span><br><span class="line">//  Branchless - Sorted</span></span><br><span class="line"><span class="built_in">seconds</span> = <span class="number">3.186068823</span></span><br></pre></td></tr></table></figure></p>
<p>观测结果：</p>
<ul>
<li>使用分支语句：排序和未排序的数据处理效率差异巨大。</li>
<li>消除分支语句：排序和未排序的数据没有区别。</li>
<li>使用C++时，消除分支语句的执行速度是比使用分支处理排序后的数据的速度慢一点的。</li>
</ul>
<p>所以一般的最佳做法是避免在重要的循环中使用依赖数据特性的分支。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/09/16/关于《理想国》/">
                关于《理想国》
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-09-16
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Philosophy/">Philosophy</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>整个西方哲学只不过是一连串柏拉图的注脚而已。<br><br><br>人的认知状态分成不同等级：从最低级的想像，到信念，再到思想，最高的认知是理解。<br><br><br>洞穴假说：每一次上升，每一次转向光，他都会眼睛痛，恨不得返回从前的状态。但一旦他习惯于新的明亮世界，他会为自己脱离以前的黑暗愚昧状态而庆幸，并可怜仍然生活在那里的同伴。<br><br><br>有多少人反思过自己的伦理道德标准的有效性和有限性。<br><br><br>所谓“解救”，是让人把头转过去，将灵魂进行转向。转了向，就看到了火。而这其实就是使灵魂得到了光明。我们经常讲的“启蒙”一次就是enlightment，字面意义是“在灵魂中(en)有了光(light)”。<br><br><br>把哲学分门别类是柏拉图的学生亚里士多德的事。<br><br><br>四大主德：正义，勇敢，节制，智慧。<br><br><br>一种观点可能被驳倒，但这不等于说这种观点一定是错的。<br><br><br>按照苏格拉底的观点，任何惩罚，应当是教育性的。唯有当某种惩罚是为了改进某个人的灵魂，才有正当性。<br><br><br>人们称颂正义，并不是因为他们认为正义好于不正义，而是因为他们乐于别人对他们正义。<br><br><br>正确的理解是，正义或道德自身就是幸福的内在构成部分，幸福不是正义的处在目的，而是依附于正义的。<br><br><br>苏格拉底，柏拉图，亚里士多德都是反民主的。在某种程度上是现代民主制的敌人。<br><br><br>有些人在理想城邦中的地位较低，由此会心生不满。但这只是因为他们不明白，他们的地位其实是他们自然地应当占有的位置。真理只能为社会中的一小部分人发现并掌握。社会中的大部分人都生活在洞穴之中，没有办法自己发现真理。<br><br><br>在柏拉图看来，底阶层受到一点欺骗却可以按自然而生活，这应是值得的。<br><br><br>凡是人类拥有的恶，奥林匹斯山上的诸神无不具有。<br><br><br>人类有一种惰性，即灵魂很容易被同化为我们所看到，所听到的东西。<br><br><br>悲剧是危险的，它破坏了对有关道德问题寻求单一理性答案的努力。<br><br><br>专制主义也有比较温和的形式。那就是，个人是整体的成员，但国家的功能与目的只是要促进公民的福祉，国家并无除此而外的独立利益。这种温和的形式也可叫做权威主义或家长制。<br><br><br>柏拉图确定了灵魂的三个部分：欲望，理性和激情。<br><br><br>所谓的意志薄弱现象的出现并不是因为人们对快乐的欲求战胜了人们对好或善的欲求，而是因为人类根本不知道什么是好，没有关于好的真正的知识。<br><br><br>所以，当人们以为出现意志薄弱的情况时，其实所犯的真正错误是无知。<br><br><br>对“什么是x”这类问题的回答应当找到一个形式(eidos)F。它呈现在一切被称为F的事物中，是所有F事物都共有的F这一属性。因为它，F的事物才成为F。一个适当的定义必须找到这样的形式。这一定义不是说明该术语的日常用法，而是要揭示该术语所代表的客观的共同本质。<br><br><br>总之，知道某个事物是否具有某种属性并不是古代哲人所关心的事情。他们所关注的是不希望看到人们处于混乱，困惑的状态，而要让人们能够去除无知，并且自我意识到自己处于明白的状态。<br><br><br>历史上的苏格拉底亦有名言曰，光喝水不喝酒是产生不了智慧的。<br><br><br>真正的哲学家是没有统治欲望的。<br><br><br>“善自身在理智领域中与理智和可知事物的关系，就如同太阳在可见世界中视力和可见事物的关系一样”。理智把握可知事物即形式，得到知识，就正如视力在可见世界中观看可感事物而得到感觉一样。<br><br><br>形式是用来说明具体事物的“是”或存在(being)的；而善的形式则是用来说明形式的“是”或存在。<br><br><br>在柏拉图看来不懂数学是无法超越可感世界而进入可知世界的。<br><br><br>如果说一个人能够思想了，或开始思想了，那就是说他或她能够解脱习俗樊篱的束缚，破除对日常经验的顺随，而开始对其自身所处的世界进行批判性的思考。<br><br><br>教育在柏拉图那里不是对知识和信息的获得，不是把知识放进灵魂。教育是让灵魂转向其应该关注的对象和方向上去，让它能使用自身的能力去看。<br><br><br>数与计算是为一切思想，一切技艺所共同使用的东西。<br><br><br>数学自然能够将人从可感事物上升到形式。<br><br></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/08/06/Alice-Where-Art-Thou/">
                Alice, Where Art Thou?
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-08-06
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/NONSENSE/">NONSENSE</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p style="text-align:center">Quaint child, old-fashioned Alice, lend your dream:<br>I would be done with modern story-spinners,<br>Follow with you the laughter and the gleam:<br>Weary I am, this night, of saints and sinners.<br>We have been friends since Lewis and old Tenniel<br>Housed you immortally in red and gold.<br>Come! Your naivete is a spring perennial:<br>Let me be young again before I am old.<br><br><br>You are a glass of youth: this night I choose<br>Deep in your magic labyrinths to stray,<br>Where rants the Red Queen in her splendid hues<br>And the Write Rabbit hurries on his way.<br>Let us once more adventure, hand in hand:<br>Give me belief again—— in Wonderland!<br></p>

<p style="text-align:right">——Vincent Starret, in <i>Brillig</i></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/08/03/playing-python-lambda/">
                玩转Python Lambda
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-08-03
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Memo/">Memo</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>最近在学习函数式编程，又想顺便学下大名鼎鼎的<strong>Python</strong> ，遂把<strong>The little schemer</strong>里的<strong>scheme</strong>代码全部用<strong>Python</strong>实现了一遍。<br>函数式编程的精髓当然是传说中的<strong>lambda</strong>表达式，本来打算用<strong>Python lambda</strong>实现<strong>scheme</strong>代码，没想到网上一查<strong>API</strong>，却发现<strong>Python lambda</strong>实在是做的弱到不行……不能缩进（一个<strong>lambda</strong>函数只能写在一行），只能用<strong>if…else…</strong>，只能写一条语句等等。</p>
<blockquote>
<p>“Why can’t lambda expressions contain statements?</p>
<p>Python lambda expressions cannot contain statements because Python’s syntactic framework can’t handle statements nested inside expressions. However, in Python, this is not a serious problem. Unlike lambda forms in other languages, where they add functionality, Python lambdas are only a shorthand notation if you’re too lazy to define a function.</p>
<p>Functions are already first class objects in Python, and can be declared in a local scope. Therefore the only advantage of using a lambda instead of a locally-defined function is that you don’t need to invent a name for the function – but that’s just a local variable to which the function object (which is exactly the same type of object that a lambda expression yields) is assigned!”</p>
</blockquote>
<p>为啥<strong>lambda</strong>表达式不能包含语句？</p>
<p>以上是<strong>Python</strong>官方<strong>FAQ</strong>给出的答复：<strong>lambda</strong>表达式就是给你偷懒少打几个字用的，不支持在语句中嵌套表达式。</p>
<p>基本上<strong>Python Lambda</strong>就应用在以下场景：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = lambda x, y: x + <span class="literal">y</span></span><br><span class="line"><span class="keyword">g</span> = lambda x: x + 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>(<span class="literal">f</span>(1, 2))</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">g</span>(1))</span><br></pre></td></tr></table></figure></p>
<p>这匿名函数还tm有个名字。<br>或者你可以节约名字:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print<span class="list">(<span class="list">(<span class="keyword">lambda</span> x, y: x + y)</span><span class="list">(<span class="number">1</span>, <span class="number">2</span>)</span>)</span></span><br><span class="line">print<span class="list">(<span class="list">(<span class="keyword">lambda</span> x: x + <span class="number">1</span>)</span><span class="list">(<span class="number">1</span>)</span>)</span></span><br></pre></td></tr></table></figure></p>
<p>是不是觉得还不如这样：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="number">1</span> + <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="number">1</span> + <span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>不得不说<strong>Python lambda</strong>简直是鸡肋。</p>
<p>但是，你注意到<strong>Python lambda</strong>支持<strong>if…else…</strong>语句了吗，<strong>scheme</strong>也只有<strong>cond…else</strong>这一种控制语句，却是非常优美的函数式<strong>PL</strong>。<br>所以我试着用<strong>if…else…</strong>来搞点名堂。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: <span class="keyword">True</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>上面的函数判断一个数是不是偶数，其中<strong>if…else…</strong>是<strong>Python lambda</strong>的标准用法。<br>冒号后面接返回值<strong>return-expression</strong>，接着是该返回值的条件<strong>cond-expression</strong>，接着<strong>else</strong>，然后是<strong>else</strong>的返回值。<br><strong>Python lambda</strong>总共以下2种写法，一种是不含<strong>if…else…</strong>的，一种是包含<strong>if…else…</strong>的：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lambda &lt;args&gt;: &lt;<span class="keyword">return</span>-<span class="keyword">expression</span>&gt;</span><br><span class="line">lambda &lt;args&gt;: &lt;<span class="keyword">return</span>-<span class="keyword">expression</span>&gt; <span class="keyword">if</span> &lt;cond-<span class="keyword">expression</span>&gt; <span class="keyword">else</span> &lt;<span class="keyword">return</span>-<span class="keyword">expression</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>第二条语句的<strong>“&lt; return-expression &gt; if &lt; cond-expression &gt; else &lt; return-expression &gt;”</strong> 整体也是一个<strong>return-expression</strong>。<br>所以我们可以在<strong>else</strong>后的<strong>return-expression</strong>中嵌套<strong>return-expression</strong>来完成复杂的条件判断语句：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda &lt;args&gt;: &lt;<span class="keyword">return</span>-<span class="keyword">expression</span>&gt; <span class="keyword">if</span> &lt;cond-<span class="keyword">expression</span>&gt; <span class="keyword">else</span> (&lt;<span class="keyword">return</span>-<span class="keyword">expression</span>&gt; <span class="keyword">if</span> &lt;cond-<span class="keyword">expression</span>&gt; <span class="keyword">else</span> &lt;<span class="keyword">return</span>-<span class="keyword">expression</span>&gt;)</span><br></pre></td></tr></table></figure></p>
<p>如果想要在匿名函数中做一些除了<strong>return-expression</strong>，其他事情（比如说<strong>print()</strong>）,应该怎么写？<br>确实不太好写，不过我还是想出了一个非常<strong>投机取巧</strong>的办法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: <span class="keyword">True</span> <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> print(x) == <span class="keyword">None</span> <span class="keyword">else</span> x<span class="string">")</span></span><br></pre></td></tr></table></figure></p>
<p>上面这个函数不仅返回了<strong>x</strong>的值，并且还打印了<strong>x</strong>，这里我把需要执行的语句(<strong>print()</strong>)转换成了逻辑表达式，而且是一个永远为真的表达式，它一定会执行，并且对业务的逻辑判断没有影响。<br>前提是你必须准确的知道需要执行的语句的返回值，才能写出永远为真的表达式。再写一个例子：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda x, <span class="keyword">l</span>: <span class="keyword">l</span> <span class="keyword">if</span> <span class="keyword">l</span>.insert(0,x) == None <span class="keyword">else</span> <span class="keyword">l</span></span><br></pre></td></tr></table></figure></p>
<p>上面这个函数把元素<strong>x</strong>插入到<strong>l</strong>的头部，并返回<strong>l</strong>。<br>通过这种<strong>投机取巧</strong>的办法我们可以大大扩充<strong>Python lambda</strong>的功能。</p>
<p><strong>Python lambda</strong>还可以返回异常：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda x: <span class="function"><span class="title">TypeError</span><span class="params">(<span class="string">"x is zero."</span>)</span></span> <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">else</span> <span class="number">5</span>/x</span><br></pre></td></tr></table></figure></p>
<p>那么迭代（循环）怎么写？<br>迭代确实是一个难题，<strong>scheme</strong>这样没有迭代的语句是怎么实现迭代的？递归。<br>首先我们先用常规函数的递归实现迭代：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#求和递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_recur</span><span class="params">(l)</span>:</span></span><br><span class="line">  <span class="keyword">if</span> len(l) == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> l[<span class="number">0</span>] + sum_recur(l[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment">#求和迭代版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_iter</span><span class="params">(l)</span>:</span></span><br><span class="line">  sum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    sum += i</span><br><span class="line">  <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>以上2个函数均实现了<strong>list l</strong>中元素求和，功能上是等价的。</p>
<p>但是匿名函数要递归调用自身难度很高。<br>以下可能有点高能，初学者慎入。<br>首先要知道，<strong>lambda</strong>表达式也是一个<strong>return-expression</strong>。所以我们还可以在<strong>lambda</strong>中返回<strong>lambda</strong>：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda <span class="tag">&lt;<span class="title">args</span>&gt;</span>: lambda <span class="tag">&lt;<span class="title">args</span>&gt;</span>: <span class="tag">&lt;<span class="title">return-expression</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>先看看下面这个函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(f)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span> l:<span class="number">0</span> <span class="keyword">if</span> len(l) == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + f(f)(l[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">print(sum(sum)([<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></p>
<p>这个函数接受一个自身作为参数，返回值是一个求和函数，也就是实际的递归本体，即<strong>sum(sum) = lambda l:0 if len(l) == 0 else l[0] + sum(sum)(l[1:])</strong>,如此实现递归调用自身。<br>我们先把<strong>sum(f)</strong>转换成<strong>lambda</strong>函数：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def <span class="function"><span class="title">sum</span><span class="params">(f)</span></span>:</span><br><span class="line">  return lambda l:<span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span></span><br><span class="line"></span><br><span class="line">lambda f: lambda l:<span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span></span><br></pre></td></tr></table></figure></p>
<p>上述2个函数式功能是等价的,返回值都相同，只是一个有名字而已，匿名函数没有名字如何调用自身？也是通过函数的参数，并且直接使用自身的定义，所以我们可以令<strong>sum(sum)</strong>为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sum</span><span class="params">(lambda f: lambda l:<span class="number">0</span> if len(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span>)</span><br><span class="line">#第二个sum，也就是作为参数的sum已被等价的lambda替换，</span><br><span class="line">#现在我们再来替换第一个sum</span><br><span class="line">(lambda f: lambda l:<span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span>) (lambda f: lambda l:<span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span>)</span><br></pre></td></tr></table></figure></p>
<p>这就完成了匿名函数递归调用自身。测试：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (lambda f: lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span>) (lambda f: lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(l[<span class="number">1</span>:])</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(g([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span>)</span><br></pre></td></tr></table></figure>
<p>接下来优化一下~</p>
<p>注意到<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(x)</span></span></span><br><span class="line">#等价于</span><br><span class="line"><span class="id">#lambda</span> x: <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(x)</span></span></span><br><span class="line"></span><br><span class="line">#那么我们可以把上面出现的<span class="function"><span class="title">f</span><span class="params">(f)</span></span>都用参数替换，然后传一个lambda x: <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(x)</span></span>作为参数即可</span><br><span class="line">g = (lambda f: lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + (lambda x: <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(x)</span></span>)(l[<span class="number">1</span>:])) (lambda f: lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + (lambda x: <span class="function"><span class="title">f</span><span class="params">(f)</span><span class="params">(x)</span></span>)(l[<span class="number">1</span>:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = (lambda y: (lambda f:lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(l[<span class="number">1</span>:])</span></span>)(lambda x: <span class="function"><span class="title">y</span><span class="params">(y)</span><span class="params">(x)</span></span>))(lambda y: (lambda f:lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(l[<span class="number">1</span>:])</span></span>)(lambda x: <span class="function"><span class="title">y</span><span class="params">(y)</span><span class="params">(x)</span></span>))</span><br><span class="line">#注意：</span><br><span class="line">lambda f:lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(l[<span class="number">1</span>:])</span></span></span><br><span class="line">#此函数就是真正的业务递归过程，其他结构均是辅助，我们可以提取出来</span><br><span class="line">job = lambda f:lambda l: <span class="number">0</span> <span class="keyword">if</span> <span class="function"><span class="title">len</span><span class="params">(l)</span></span> == <span class="number">0</span> <span class="keyword">else</span> l[<span class="number">0</span>] + <span class="function"><span class="title">f</span><span class="params">(l[<span class="number">1</span>:])</span></span></span><br><span class="line"></span><br><span class="line">g = (lambda y: <span class="function"><span class="title">job</span><span class="params">(lambda x: y(y)</span><span class="params">(x)</span></span>))(lambda y: <span class="function"><span class="title">job</span><span class="params">(lambda x: y(y)</span><span class="params">(x)</span></span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(g([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span></span>)</span><br></pre></td></tr></table></figure></p>
<p>这个<strong>g</strong>就是传说中的上古神器<strong>Y-Combinator</strong>！它就是一个通用的匿名函数递归公式。</p>
<p>至此，我们已经把<strong>Python lambda</strong>的功能扩充的基本和普通函数差不多了（额，可能还差一点）。<br>而且所有函数全部一行完成，然而并没有什么卵用。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/21/Python-eval和ast-literal-eval/">
                Python eval和ast.literal_eval
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-21
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Memo/">Memo</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><code>datamap = eval(raw_input(&#39;Provide some data here: &#39;)</code> means that you actually evaluate the code before you deem it to be unsafe or not. It evaluates the code as soon as the function is called. See also the dangers of <code>eval</code>.</p>
<p><code>ast.literal_eval</code> raises an exception if the input isn’t a valid Python datatype, so the code won’t be executed if it’s not.</p>
<p><strong>Use <code>ast.literal_eval</code> whenever you need <code>eval</code>.</strong> If you have Python expressions as an input that you want to evaluate, you shouldn’t (have them).</p>
<hr>
<p>简而言之一句话，<code>literal_eval</code>做了类型检查，如果参数无效的话就会报错，而<code>eval</code>不会。所以尽量使用<code>literal_eval</code>。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/06/The-Little-Book-of-Semaphores/">
                The Little Book of Semaphores
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-06
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Books/">Books</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p><img src="https://github.com/locatino/locatino.github.io/raw/master/images/book-the-little-book-of-semaphores.jpg" alt=""><br>本书教授了如何理解多线程执行和如何解决同步问题。尤其推荐给自学和初学者。<br>里面一步步教导读者解决一系列的经典和不那么经典的同步问题。内容非常有趣。<br>下载链接：<a href="http://www.greenteapress.com/semaphores/downey08semaphores.pdf" target="_blank" rel="external">http://www.greenteapress.com/semaphores/downey08semaphores.pdf</a></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/07/01/极端编程主义/">
                极端编程主义
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-07-01
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Translation/">Translation</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <pre><code>函数（<span class="built_in">Function</span>）太棒了。如果我们创造一门只有函数的语言会如何？
对象（<span class="built_in">Object</span>）太棒了。如果我们创造一门一切都是对象的语言会如何？
惰性求值（Lazy evaluation）太棒了。如果我们创造一门所有类型都是惰性的语言会如何？
</code></pre><p>极端主义编程（Extremist Programming, 与极限编程无关）是一种奉行某种思想（Principle），用它来衡量其他一切事物并将它应用在任何地方的行为。等到尘埃落定之后，人们通常会对着这种极端主义方式思考，“额，这确实很有趣，但是把X用在Y里明显不恰当。你需要换一种正确的方式来达到目的！”</p>
<p>上面这段话的意思是：有时候你需要使用错误的工具工作，因为你并不知道用这工具是不是正确的。如果你不到处使用函数，你也许就不明白将一个函数作为另一个函数的参数有怎样的功效，也许就不明白Cheap Lambda表达式的意义。如果你不到处使用对象，你也许就不理解其实整型和类的实例其实都是对象。如果你不到处使用惰性求值，你也许就没意识到其实函数的纯粹性（Purity）其实是一种更加重要的语言特征。</p>
<p>这就引出了两个建议：</p>
<ol>
<li><p>当学习一种新的思想时，尝试将它到处运用一番。这样你就可以很快的知道它什么时候适用什么时候不适用，即使你对它的第一印象全是错的。（另一方面，如果你没有进行这样错误的尝试的话，你将失去对它适用范围理解的机会。）</p>
</li>
<li><p>当试图理解某种思想的本质时，一个极端的例子是最清晰明了的。如果你想知道使用惰性求值编程是怎么样的，你会使用Haskell，而不是其他的非强制惰性求值的语言。即使这样极端的系统并不实用，但它确实能够更好的体现本质。</p>
</li>
</ol>
<p>极端主义在很多场合并不恰当，但是对于那些有趣的，小巧的项目或者研究，它真的能够教会你许多。给我印象最深的一件事情就是我去年和Adam Chlipala的合作。当时我们用Coq进行一些证明，我用的是中规中矩的方式，先一步一步推导要证的雏形，然后使用Ltac自动证明。Adam告诉我：“你应该一开始就自动证明的，不用麻烦的做手工推导”。真是醍醐灌顶：我就是不够极端！</p>
<pre><code>文件（<span class="keyword">File</span>）太棒了。如果我们创造一种一切都是文件的操作系统会如何？
<span class="keyword">Cons</span>结构（<span class="keyword">Cons</span> cell）太棒了。如果我们创造一种一切都由<span class="keyword">Cons</span>组成的编程语言会如何？
数学（Mathematics）太棒了。如果我们创造一种一切都是数学说了算的编程语言会如何？
数组（Array）太棒了。如果我们创造一种一切都是数组的语言会如何？
</code></pre><hr>
<p>翻译 by locatino<br>原文链接<a href="http://blog.ezyang.com/2012/11/extremist-programming/" target="_blank" rel="external">http://blog.ezyang.com/2012/11/extremist-programming/</a></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/29/一个通用的java程序控制脚本/">
                一个通用的Java程序控制脚本
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-29
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/Memo/">Memo</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>修改相应的参数就可以很方便的控制各类Java程序。<br>将脚本置于bin目录下，<br>推荐目录格式:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#62; application&#10;&#9;&#62; bin&#10;&#9;&#62; lib&#10;&#9;&#62; log&#10;&#9;&#62; conf</span><br></pre></td></tr></table></figure></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/sh&#10;#-------------------------------------------------------------------&#10;# &#23450;&#20041;&#21464;&#37327;&#10;#-------------------------------------------------------------------&#10;&#10;libdir=../lib&#10;# &#27169;&#22359;&#21517;(&#31243;&#24207;&#30340;&#21807;&#19968;&#26631;&#35782;)&#10;MODEL_NAME=test&#10;# &#27169;&#22359;&#36816;&#34892;&#38656;&#35201;&#30340;lib&#10;MODEL_LIBS=`./stoc.sh $&#123;libdir&#125;`&#10;# &#36873;&#39033;(java&#21551;&#21160;&#21442;&#25968;)&#10;MODEL_OPTS=&#34;-Xmx128m -DConfig=../conf/db.xml -DtaskConfig=../conf/taskConfig.xml -Dlog4j.configuration=file:../conf/cmdcenter.log4j&#34;&#10;# &#36816;&#34892;&#31867;&#21517;(main&#20989;&#25968;&#25152;&#22312;&#31867;)&#10;MODEL_CLASS=&#34;com.locatino.server.TestServer&#34;&#10;# &#36816;&#34892;&#21442;&#25968;&#10;MODEL_VARS=&#34;0&#34;&#10;# &#21069;&#21488;/&#21518;&#21488;: 0-&#21069;&#21488;&#65292; 1-&#21518;&#21488;&#10;MODEL_DAEMON=1&#10;# &#26085;&#24535; &#39;&#38;-&#39;:&#34920;&#31034;&#20851;&#38381;&#26631;&#20934;&#36755;&#20986;&#26085;&#24535;&#10;MODEL_LOG=&#34;../log/error.log&#34;&#10;#-------------------------------------------------------------------&#10;# &#20197;&#19979;&#20869;&#23481;&#35831;&#19981;&#35201;&#20462;&#25913;&#10;#-------------------------------------------------------------------&#10;SLEEP_MIN=5&#10;# model info can be define here&#10;MODEL_SYMBOL=$&#123;MODEL_NAME&#125;&#10;GREP_KEY=&#34;Diname=&#34;$&#123;MODEL_SYMBOL&#125;&#10;# CLASSPATH can bu define here&#10;CLASSPATH=$&#123;MODEL_LIBS&#125;:.:$&#123;CLASSPATH&#125;&#10;#----------------------------------------------------------&#10;# function print usage&#10;#----------------------------------------------------------&#10;print_usage()&#10;&#123;&#10;echo &#34;&#34;&#10;echo &#34;\th|H|help|HELP             \tPrint help information.&#34;&#10;echo &#34;\tstart                     \tStart the $&#123;MODEL_NAME&#125; server.&#34;&#10;echo &#34;\tstop                      \tStop the $&#123;MODEL_NAME&#125; server.&#34;&#10;echo &#34;\tstatus                    \tStatus the $&#123;MODEL_NAME&#125; server.&#34;&#10;&#125;&#10;#-------------------------------------------------------------------&#10;# function model_is_exist&#10;#-------------------------------------------------------------------&#10;modelService_is_exist()&#10;&#123;&#10;localServerId=`ps -ef |grep &#34;$&#123;GREP_KEY&#125;&#34; | grep -v grep | awk &#39;&#123;print $2&#125;&#39;`&#10;if [ -z &#34;$&#123;localServerId&#125;&#34; ]&#10;then&#10;return 1&#10;else&#10;return 0&#10;fi&#10;&#125;&#10;#-------------------------------------------------------------------&#10;# function model_start&#10;#-------------------------------------------------------------------&#10;model_start ()&#10;&#123;&#10;modelService_is_exist&#10;if [ $? -eq &#34;0&#34; ]&#10;then&#10;        echo &#34;$&#123;MODEL_NAME&#125; is running yet. pid $&#123;localServerId&#125;.&#34;&#10;        return 0&#10;else&#10;        if [ $MODEL_DAEMON = 0 ]&#10;        then&#10;                echo &#34;try to start $&#123;MODEL_NAME&#125; ... foreground&#34;&#10;                $JAVA_HOME/bin/java -$&#123;GREP_KEY&#125; -classpath $&#123;CLASSPATH&#125; $&#123;MODEL_OPTS&#125; $&#123;MODEL_CLASS&#125; $&#123;MODEL_VARS&#125;&#10;        else&#10;                echo &#34;try to start $&#123;MODEL_NAME&#125; ... backgroud&#34;&#10;                nohup $JAVA_HOME/bin/java -$&#123;GREP_KEY&#125; $&#123;MODEL_OPTS&#125; -classpath $&#123;CLASSPATH&#125; $&#123;MODEL_CLASS&#125; $&#123;MODEL_VARS&#125; 1&#62;&#38;- 2&#62;&#62;$&#123;MODEL_LOG&#125; &#38;&#10;                sleep $SLEEP_MIN&#10;                modelService_is_exist&#10;                if [ $? -eq &#34;0&#34; ]&#10;                then&#10;                        echo &#34;$&#123;MODEL_NAME&#125; is running now. pid $&#123;localServerId&#125;.&#34;&#10;                        return 0&#10;                else&#10;                        echo &#34;failed to start $&#123;MODEL_NAME&#125;! see the output log for more details.&#34;&#10;                        return 1&#10;                fi&#10;        fi&#10;fi&#10;&#125;&#10;#-------------------------------------------------------------------&#10;# function model_stop&#10;#-------------------------------------------------------------------&#10;model_stop()&#10;&#123;&#10;echo &#34;try to stop $&#123;MODEL_NAME&#125; ...&#34;&#10;modelService_is_exist&#10;if [ $? -eq 0 ]&#10;then&#10;/usr/bin/kill $&#123;localServerId&#125;&#10;if [ $? -ne 0 ]&#10;then&#10;echo &#34;failed to stop $&#123;MODEL_NAME&#125;!&#34;&#10;return 1&#10;else&#10;echo &#34;$&#123;MODEL_NAME&#125; stopped.&#34;&#10;return 0&#10;fi&#10;else&#10;echo &#34;$&#123;MODEL_NAME&#125; is not running!&#34;&#10;return 1&#10;fi&#10;&#125;&#10;#-------------------------------------------------------------------&#10;# function model_status&#10;#-------------------------------------------------------------------&#10;model_status()&#10;&#123;&#10;modelService_is_exist&#10;if [ $? -eq 0 ]&#10;then&#10;echo &#34;$&#123;MODEL_NAME&#125; is running. pid $&#123;localServerId&#125;.&#34;&#10;else&#10;echo &#34;$&#123;MODEL_NAME&#125; is not running.&#34;&#10;fi&#10;&#125;&#10;#-------------------------------------------------------------------&#10;#&#10;#-------------------------------------------------------------------&#10;#-------------------------------------------------------------------&#10;# function parse_para&#10;#-------------------------------------------------------------------&#10;parse_para()&#10;&#123;&#10;case &#34;$1&#34; in&#10;start) model_start;;&#10;stop) model_stop;;&#10;status) model_status;;&#10;*) echo &#34;illage parameter : $1&#34;;print_usage;;&#10;esac&#10;&#125;&#10;#-------------------------------------------------------------------&#10;# main&#10;#-------------------------------------------------------------------&#10;parse_para $1</span><br></pre></td></tr></table></figure>
<p>下面是stoc.sh<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `find $1 -name &#34;*.jar&#34;` | sed -e &#39;s/ /:/g&#39;</span><br></pre></td></tr></table></figure></p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
      

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2015/06/29/第一篇/">
                Hello world
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於 2015-06-29
        </span>

        
          <span class="post-category">
            &nbsp; | &nbsp; 分類於
            
              <a href="/categories/NONSENSE/">NONSENSE</a>

              
              

            
          </span>
        

        
          
        
      </div>
    </div>

    <div class="post-body">

      
      

      
        
          <p>这是<strong>新的开始</strong>，我用hexo创建了第一篇文章。</p>
<p>感觉非常好。</p>

        
      
    </div>

    <div class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </div>
  </div>


    
  </div>

  

        </div>

        
      </div>


      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <div id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <div class="site-overview">
        <div class="site-author motion-element">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="locatino" />
          <p class="site-author-name">locatino</p>
        </div>
        <p class="site-description motion-element">“大多数人按照我们所安排的路线生活，害怕探索其它路线，但也会有一些人，他们并不满足于被设定的生活轨迹，冲破我们设置的重重阻碍，意识到自由意志是天赐之物的人，才明白只有在奋力抗争后才知道如何善用之。”</p>
        <div class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </div>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>
        
      </div>

      

    </div>
  </div>


    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">locatino</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.3"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.3"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.3" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
    });
  </script>

  

  
  
  

  




  
  

</body>
</html>
